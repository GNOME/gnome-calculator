%option 8bit reentrant bison-locations
%option never-interactive
%option noyywrap noinput nounput
%option prefix="_mp_equation_"
%option extra-type="MPEquationParserState *"
%option outfile="mp-equation-lexer.c" header-file="mp-equation-lexer.h"

%{
/*  Copyright (c) 2004-2008 Sami Pietila
 *  Copyright (c) 2008-2009 Robert Ancell
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 *  02111-1307, USA.
 */

#include <stdlib.h>
#include <locale.h>
#include <string.h>
#include <sys/types.h>

#include "mp-equation-private.h"
#include "mp-equation-parser.h"
#include "mp-equation.h"
%}


ZERO          [0Ù Û°ß€à¥¦à§¦à©¦à«¦à­¦à¯¦à±¦à³¦àµ¦à¹à»à¼ á€á‚áŸ á á¥†á§á­á®°á±€á±ê˜ ê£ê¤€ê©ð’ ]
ONE           [1Ù¡Û±ßà¥§à§§à©§à«§à­§à¯§à±§à³§àµ§à¹‘à»‘à¼¡áá‚‘áŸ¡á ‘á¥‡á§‘á­‘á®±á±á±‘ê˜¡ê£‘ê¤ê©‘ð’¡]
TWO           [2Ù¢Û²ß‚à¥¨à§¨à©¨à«¨à­¨à¯¨à±¨à³¨àµ¨à¹’à»’à¼¢á‚á‚’áŸ¢á ’á¥ˆá§’á­’á®²á±‚á±’ê˜¢ê£’ê¤‚ê©’ð’¢]
THREE         [3Ù£Û³ßƒà¥©à§©à©©à«©à­©à¯©à±©à³©àµ©à¹“à»“à¼£áƒá‚“áŸ£á “á¥‰á§“á­“á®³á±ƒá±“ê˜£ê£“ê¤ƒê©“ð’£]
FOUR          [4Ù¤Û´ß„à¥ªà§ªà©ªà«ªà­ªà¯ªà±ªà³ªàµªà¹”à»”à¼¤á„á‚”áŸ¤á ”á¥Šá§”á­”á®´á±„á±”ê˜¤ê£”ê¤„ê©”ð’¤]
FIVE          [5Ù¥Ûµß…à¥«à§«à©«à««à­«à¯«à±«à³«àµ«à¹•à»•à¼¥á…á‚•áŸ¥á •á¥‹á§•á­•á®µá±…á±•ê˜¥ê£•ê¤…ê©•ð’¥]
SIX           [6Ù¦Û¶ß†à¥¬à§¬à©¬à«¬à­¬à¯¬à±¬à³¬àµ¬à¹–à»–à¼¦á†á‚–áŸ¦á –á¥Œá§–á­–á®¶á±†á±–ê˜¦ê£–ê¤†ê©–ð’¦]
SEVEN         [7Ù§Û·ß‡à¥­à§­à©­à«­à­­à¯­à±­à³­àµ­à¹—à»—à¼§á‡á‚—áŸ§á —á¥á§—á­—á®·á±‡á±—ê˜§ê£—ê¤‡ê©—ð’§]
EIGHT         [8Ù¨Û¸ßˆà¥®à§®à©®à«®à­®à¯®à±®à³®àµ®à¹˜à»˜à¼¨áˆá‚˜áŸ¨á ˜á¥Žá§˜á­˜á®¸á±ˆá±˜ê˜¨ê£˜ê¤ˆê©˜ð’¨]
NINE          [9Ù©Û¹ß‰à¥¯à§¯à©¯à«¯à­¯à¯¯à±¯à³¯àµ¯à¹™à»™à¼©á‰á‚™áŸ©á ™á¥á§™á­™á®¹á±‰á±™ê˜©ê£™ê¤‰ê©™ð’©]
/* FIXME: DECIMAL and TSEP needs to figure out, at runtime, the correct
 * character. I can't figure out how to make flex do this, so I send
 * everything at mp_set_from_string and let it fail. This is slow.
 */
DECIMAL       .
TSEP          .
DEC           {ZERO}|{ONE}|{TWO}|{THREE}|{FOUR}|{FIVE}|{SIX}|{SEVEN}|{EIGHT}|{NINE}
HEX           {DEC}|[A-F]|[a-f]
SUPER_DIGITS  [â°Â¹Â²Â³â´âµâ¶â·â¸â¹]
SUPER_MINUS   "â»"
SUB_DIGITS    [â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰]
FRACTION      [Â½â…“â…”Â¼Â¾â…•â…–â…—â…˜â…™â…šâ…›â…œâ…â…ž]
GREEKS        [Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰]
DEGREES       "Â°"
MINUTES       "'"
SECONDS       "\""
LETTERS       [a-zA-Z]|{GREEKS}

SUP_NUM  {SUPER_DIGITS}+
NSUP_NUM {SUPER_MINUS}{SUPER_DIGITS}+
SUB_NUM  {SUB_DIGITS}+
WORD     {LETTERS}+
DEC_TSEP {DEC}{1,3}({TSEP}?{DEC}{3})*
HEX_TSEP {HEX}{1,3}({TSEP}?{HEX}{3})*
DEC_NUM  {DEC_TSEP}|{DEC_TSEP}?{DECIMAL}{DEC}+
DEF_NUM  {HEX_TSEP}|{HEX_TSEP}?{DECIMAL}{HEX}+
BASE_NUM {HEX_TSEP}{SUB_NUM}|{HEX_TSEP}?{DECIMAL}{HEX}+{SUB_NUM}
ANGLE_NUM {DEC_NUM}{DEGREES}|{DEC}+{DEGREES}{DEC_NUM}{MINUTES}|{DEC}+{DEGREES}{DEC}+{MINUTES}{DEC_NUM}{SECONDS}

NUMBER   {DEF_NUM}|{BASE_NUM}|{FRACTION}|{DEC}+{FRACTION}|{ANGLE_NUM}
VARIABLE {WORD}|{WORD}{SUB_NUM}|{GREEKS}

MOD  [mM][oO][dD]
AND  "âˆ§"|[aA][nN][dD]
OR   "âˆ¨"|[oO][rR]
XOR  [âŠ»âŠ•]|[xX][oO][rR]
NOT  [Â¬~]|[nN][oO][tT]
RE   "âƒ°â„œ"
IM   "â„‘"
IN   [iI][nN]

%%

"+"         {return tADD;}
"-"|"âˆ’"     {return tSUBTRACT;}
"*"|"Ã—"     {return tMULTIPLY;}
"/"|"âˆ•"|"Ã·" {return tDIVIDE;}
{MOD}       {return tMOD;}
"âŒŠ"         {return tLFLOOR;}
"âŒ‹"         {return tRFLOOR;}
"âŒˆ"         {return tLCEILING;}
"âŒ‰"         {return tRCEILING;}
"âˆš"         {return tROOT;}
"âˆ›"         {return tROOT3;}
"âˆœ"         {return tROOT4;}
{NOT}       {return tNOT;}
{AND}       {return tAND;}
{OR}        {return tOR;}
{XOR}       {return tXOR;}
{IN}        {return tIN;}
{NUMBER}    {if (mp_set_from_string(yytext, _mp_equation_get_extra(yyscanner)->options->base, &yylval->int_t) != 0) REJECT; return tNUMBER;}
{SUP_NUM}   {yylval->integer = super_atoi(yytext); return tSUPNUM;}
{NSUP_NUM}  {yylval->integer = super_atoi(yytext); return tNSUPNUM;}
{SUB_NUM}   {yylval->integer = sub_atoi(yytext); return tSUBNUM;}
{VARIABLE}  {\
    MPEquationParserState *state = _mp_equation_get_extra(yyscanner);\
    if (state->function_is_defined(state, yytext)) {\
        yylval->name = strdup(yytext);\
        return tFUNCTION;\
    }\
    else {\
        yylval->name = strdup(yytext);\
        return tVARIABLE;\
    }\
}
[ \r\t\n]
.           {return *yytext;}

%%
